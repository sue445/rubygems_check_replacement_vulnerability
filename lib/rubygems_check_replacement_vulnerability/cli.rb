require "rubygems_check_replacement_vulnerability"
require "thor"

module RubygemsCheckReplacementVulnerability
  require "yaml"
  require "json"

  class CLI < Thor
    include ShellMethods

    desc "version", "Show version"
    def version
      puts RubygemsCheckReplacementVulnerability::VERSION
    end

    desc "vulnerable_gems", "Show vulnerable gems"
    option :username, aliases: "u", desc: "Username of rubygems.org", required: true
    option :format, aliases: "f", desc: "print format (plain, yaml, json)", default: "plain"
    def vulnerable_gems
      gems = Rubygems.owner_gems(options[:username]).select { |gem| gem.include?("-") }.sort

      vulnerable_gems =
        gems.each_with_object({}) do |gem, result|
          rubygems = Rubygems.new(gem)
          versions = rubygems.vulnerable_versions
          result[gem] = versions unless versions.empty?
        end

      case options[:format]
      when "plain"
        puts "#{options[:username]}'s vulnerable gems"

        if vulnerable_gems.empty?
          puts "Nothing!"
        else
          vulnerable_gems.each do |gem, versions|
            puts "- #{gem} : #{versions.join(", ")}"
          end
        end

      when "yaml"
        puts YAML.dump(vulnerable_gems)

      when "json"
        puts JSON.dump(vulnerable_gems)

      else
        raise "Unknown format: #{options[:format]}"
      end
    end

    desc "verify_gem", "Verify whether replacemented gem"
    option :name, aliases: "n", desc: "gem name", required: true
    option :version, aliases: "v", desc: "version to check (default: all)", required: false
    option :url, aliases: "u", desc: "git repository url (i.e. git@github.com:rails/rails.git)", required: true
    def verify_gem
      rubygems = Rubygems.new(options[:name])

      versions =
        if options[:version]
          Array(options[:version])
        else
          rubygems.vulnerable_versions
        end

      Dir.mktmpdir("repo-") do |work_dir|
        repository = Repository.new(options[:url], work_dir)
        repository.git_clone

        versions.each do |version|
          git_tag = "v#{version}"

          unless repository.tags.include?(git_tag)
            puts "[Warn] Not found tag #{git_tag} in repository"
            next
          end

          repository.checkout(git_tag)

          safe = verify(repository: repository, rubygems: rubygems, version: version)

          if safe
            puts "[Info] #{rubygems.gem_name} #{version} is safe!"
          else
            puts "[Warn] #{rubygems.gem_name} #{version} is contaminated!"
          end
        end
      end
    end

    private

    # @param repository [RubygemsCheckReplacementVulnerability::Repository]
    # @param rubygems [RubygemsCheckReplacementVulnerability::Rubygems]
    # @param version [String]
    def verify(repository:, rubygems:, version:)
      safe = true

      Dir.mktmpdir("gem-") do |gem_dir|
        gem_path = rubygems.download_gem(version, gem_dir)
        gem_name_with_ext = File.basename(gem_path)
        gem_name_without_ext = File.basename(gem_path, ".gem")

        Dir.chdir(gem_dir) do
          run "gem unpack #{gem_name_with_ext} --quiet"

          Dir.chdir(gem_name_without_ext) do
            unpacked_file = Pathname.glob("**/**").select(&:file?)
            unpacked_file.each do |unpacked_file|
              repo_file = repository.find_file(unpacked_file)
              unless repo_file.exist?
                puts "Not found #{unpacked_file} in repository"
                safe = false
                next
              end

              unless unpacked_file.size == repo_file.size
                puts "Expect #{unpacked_file} is #{unpacked_file.size} bytes, but actual #{repo_file.size} bytes!"
                safe = false
                next
              end

              unless unpacked_file.read == repo_file.read
                puts "#{unpacked_file} is not match between gem file and repository!"
                safe = false
                next
              end

              # puts "#{unpacked_file}: ok"
            end
          end
        end
      end

      safe
    end
  end
end
