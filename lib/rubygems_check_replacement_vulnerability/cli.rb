require "rubygems_check_replacement_vulnerability"
require "thor"

module RubygemsCheckReplacementVulnerability
  require "yaml"
  require "json"

  class CLI < Thor
    include ShellMethods

    desc "version", "Show version"
    def version
      puts RubygemsCheckReplacementVulnerability::VERSION
    end

    desc "vulnerable_gems", "Show vulnerable gems"
    option :username, aliases: "u", desc: "Username of rubygems.org", required: true
    option :format, aliases: "f", desc: "Print format (plain, yaml, json)", default: "plain"
    def vulnerable_gems
      gems = Rubygems.owner_gems(options[:username]).select { |gem| gem.include?("-") }.sort

      vulnerable_gems =
        gems.each_with_object({}) do |gem, result|
          rubygems = Rubygems.new(gem)
          versions = rubygems.vulnerable_versions
          result[gem] = versions unless versions.empty?
        end

      case options[:format]
      when "plain"
        puts "#{options[:username]}'s vulnerable gems"

        if vulnerable_gems.empty?
          puts "Nothing!"
        else
          vulnerable_gems.each do |gem, versions|
            puts "- #{gem} : #{versions.join(", ")}"
          end
        end

      when "yaml"
        puts YAML.dump(vulnerable_gems)

      when "json"
        puts JSON.dump(vulnerable_gems)

      else
        raise "Unknown format: #{options[:format]}"
      end
    end

    desc "verify_gem", "Verify whether replacemented gem"
    option :name, aliases: "n", desc: "Gem name", required: true
    option :version, aliases: "v", desc: "Version to check (default: all vulnerable versions)", required: false
    option :repo_url, aliases: "u", desc: "Git repository url (e.g. git@github.com:rails/rails.git)", required: true
    def verify_gem
      rubygems = Rubygems.new(options[:name])

      versions =
        if options[:version]
          Array(options[:version])
        else
          rubygems.vulnerable_versions
        end

      Dir.mktmpdir("repo-") do |work_dir|
        repository = Repository.new(options[:repo_url], work_dir)
        repository.git_clone

        versions.each do |version|
          git_tag = "v#{version}"

          unless repository.tags.include?(git_tag)
            puts "[Warn] Not found tag #{git_tag} in repository"
            next
          end

          repository.checkout(git_tag)

          safe = verify?(repository: repository, rubygems: rubygems, version: version)

          if safe
            puts "[Info] #{rubygems.gem_name} #{version} is safe!"
          else
            puts "[Warn] #{rubygems.gem_name} #{version} is contaminated!"
          end
        end
      end
    end

    no_commands do
      # @param repository [RubygemsCheckReplacementVulnerability::Repository]
      # @param rubygems [RubygemsCheckReplacementVulnerability::Rubygems]
      # @param version [String]
      def verify?(repository:, rubygems:, version:)
        safe = true

        Dir.mktmpdir("gem-") do |gem_dir|
          gem_path = rubygems.download_gem(version, gem_dir)
          gem_basename = File.basename(gem_path, ".gem")

          run_command("gem unpack #{gem_path} --target=#{gem_dir} --quiet")

          Dir.chdir(File.join(gem_dir, gem_basename)) do
            unpacked_file = Pathname.glob("**/**").select(&:file?)
            unpacked_file.each do |unpacked_file|
              repo_file = repository.find_file(unpacked_file)
              result = verify_file?(unpacked_file, repo_file)
              safe = result unless result
            end
          end
        end

        safe
      end

      def verify_file?(unpacked_file, repo_file)
        unless repo_file.exist?
          puts "Not found #{unpacked_file} in repository"
          return false
        end

        unless unpacked_file.size == repo_file.size
          puts "Expect #{unpacked_file} is #{unpacked_file.size} bytes, but actual #{repo_file.size} bytes!"
          return false
        end

        unless unpacked_file.read == repo_file.read
          puts "#{unpacked_file} is not match between gem file and repository!"
          return false
        end

        true
      end
    end
  end
end
